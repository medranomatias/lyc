\section{Clase 20}
 
\begin{theorem}
Para cada $n$, las funciones $\phi^n$ son \textbf{parcialmente computables}. Los programas que computan estas funciones se denominan \textbf{programas universales}.
\end{theorem}
 
\begin{proof}
Utilizaremos dos funciones que son \textit{la funci\'on de longitud} y la funci\'on que devuelve para cada $i$, el exponente del $i-esimo$ n\'umero primo en la factorizaci\'on de un n\'umero $x$:
 
\[
(x)_i = maximo \{ \; n \; / \; P_{i}^{n} \mid x \}
\]
 
Construcci\'on:
 
$Z \leftarrow X_{n + 1} + 1$
 
$S \leftarrow \prod_{i}^{n} \; \rho_{2 \cdot i}^{x_i}$
 
$K \leftarrow 1$
 
$[C]\ IF \ K = L_{t}(Z) + 1 \wedge K = 0 \ GOTO \ F$
 
$U \leftarrow R((Z)_{k})$
 
$P \leftarrow P_{r(u) + 1}$
 
$IF \ \ell(U) = 0 \ GOTO \ N$
 
$IF \ \ell(U) = 1 \ GOTO \ A$
 
$IF \ \thicksim(P \mid S) \ GOTO \ N$
 
$IF \ \ell(U) = 2 \ GOTO \ M$
 
$K \leftarrow min_{i \leq t(z)}\ [\ell((z)_i) + 2 = \ell(U)]$
 
$GOTO \ C$
 
$[M] \ S \leftarrow \left[\dfrac{S}{P}\right]$
 
$GOTO \ N$
 
$[A] S \leftarrow S \cdot P$
 
$[N] K \leftarrow K + 1$
 
$GOTO C$
 
$[F] Y \leftarrow (S)_{1}$
 
\end{proof}
 
\begin{observation}
Consideremos la funci\'on $\Phi^{1}(x, y)$ devuelve el valor de la funci\'on con entrada $x$ del programa de c\'odigo $y$. Por el teorema anterior sabemos que $\Phi^{1}(x, y)$ es parcialmente computable.
 
\begin{enumerate}
	\item Si $\mathcal{F}$ es una funci\'on parcialmente computable de una variable y sea $\mathcal{P}$ un programa que computa $\mathcal{F}$, sea $Z_0 = \# P$, luego $\mathcal{F} = \Phi^{1}(x, z_0)$.
	\item Si $y = x$, $\Phi^{1}(x, x)$ es parcialmente computable. Consideremos el siguiente programa $\mathcal{P}$:
	\[
	Z \leftarrow \Phi^{1}(x, x)
	\]
	$P$ computa la funci\'on:	
	\(
	\mathcal{F} =
	\begin{cases}
	0			&\text{si } \Phi(x, x)\; \downarrow	\\
	\uparrow	&\text{sino }
	\end{cases}
	\)
	\item Ya vimos la clase pasada que $HALT(x, x)$ no es computable, reescritura del $HALT(x, y)$ en t\'erminos de $\Phi^{1}(x, y)$(las funciones universales)
	\(
	HALT(x, y) =
	\begin{cases}
	1			&\text{si } \Phi^{1}(x, y) \downarrow	\\
	0			&\text{si }	\Phi^{1}(x, y)	\uparrow
	\end{cases}
	\)	
	y, en particular,
	
	\(
	HALT(x, x) =
	\begin{cases}
	1			&\text{si } \Phi^{1}(x, x) \downarrow	\\
	0			&\text{si }	\Phi^{1}(x, x)	\uparrow
	\end{cases}
	\)
\end{enumerate}
\end{observation}
 
\begin{definition}
Si $x_1$, $x_2$, $\ldots$, $x_n$ son n\'umeros naturales, se define el siguiente predicado de $n+ 2$ variables:
 
\[
STEP^{(n)}(x_1, \ldots, x_n, y, t) =
\begin{cases}
1				&\text{si el programa de c\'odigo y, entradas $x_1, \ldots, x_n$ se detiene en a lo sumo t pasos.}\\
0				&\text{sino}
 
\end{cases}
\]
\end{definition}
 
\begin{theorem}
El predicado $STEP^{(n)}$ es un predicado recursivo primitivo de $n + 2$ variables. \textquestiondown Como se puede escribir el predicado $HALT(x, x)$ usando el predicado $STEP^{(n)}$?
 
\[
HALT(x, x) = \exists t \underbrace{STEP^{1}(x, x, t)}_{\mathcal{P}(x, t)}
\]
 
$\exists t \mathcal{P}(x, t)$ no es computable pero $\mathcal{P}(x, y)$ es computable como predicado de dos variables.
\end{theorem}
 
